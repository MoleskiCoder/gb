
<!-- saved from url=(0095)https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


<script type="text/javascript" src="https://web.archive.org/static/js/analytics.js"></script>
<script type="text/javascript">archive_analytics.values.server_name="wwwb-app6.us.archive.org";archive_analytics.values.server_ms=190;</script>
<link type="text/css" rel="stylesheet" href="./ZX81 VIDEO DISPLAY SYSTEM_files/banner-styles.css">


<title>ZX81 VIDEO DISPLAY SYSTEM</title>
<link rel="stylesheet" type="text/css" href="./ZX81 VIDEO DISPLAY SYSTEM_files/z80tab.css">
</head>
<body><div id="wm-ipp" lang="en" style="display: block;">

<div style="position:fixed;left:0;top:0;width:100%!important">
<div id="wm-ipp-inside">
   <table style="width:100%;"><tbody><tr>
   <td id="wm-logo">
       <a href="https://web.archive.org/web/" title="Wayback Machine home page"><img src="./ZX81 VIDEO DISPLAY SYSTEM_files/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0"></a>
   </td>
   <td class="c">
       <table style="margin:0 auto;"><tbody><tr>
       <td class="u" colspan="2">
       <form target="_top" method="get" action="https://web.archive.org/web/form-submit.jsp" name="wmtb" id="wmtb"><input type="text" name="url" id="wmtbURL" value="http://home.germany.net/nils.eilers/zx81/wilfvid.htm" style="width:400px;" onfocus="this.focus();this.select();"><input type="hidden" name="type" value="replay"><input type="hidden" name="date" value="20070830180756"><input type="submit" value="Go"><span id="wm_tb_options" style="display:block;"></span></form>
       </td>
       <td class="n" rowspan="2">
           <table><tbody>
           <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
           <tr class="m">
           	<td class="b" nowrap="nowrap">
		
		    <a href="https://web.archive.org/web/20061112041406/http://home.germany.net/nils.eilers/zx81/wilfvid.htm" title="12 Nov 2006">NOV</a>
		
		</td>
		<td class="c" id="displayMonthEl" title="You are here: 18:07:56 Aug 30, 2007">AUG</td>
		<td class="f" nowrap="nowrap">
		
		    <a href="https://web.archive.org/web/20071227003250/http://home.germany.net/nils.eilers/zx81/wilfvid.htm" title="27 Dec 2007"><strong>DEC</strong></a>
		
                </td>
	    </tr>
           <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
           <tr class="d">
               <td class="b" nowrap="nowrap">
               
                   <a href="https://web.archive.org/web/20061112041406/http://home.germany.net/nils.eilers/zx81/wilfvid.htm" title="4:14:06 Nov 12, 2006"><img src="./ZX81 VIDEO DISPLAY SYSTEM_files/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0"></a>
               
               </td>
               <td class="c" id="displayDayEl" style="width:34px;font-size:24px;" title="You are here: 18:07:56 Aug 30, 2007">30</td>
	       <td class="f" nowrap="nowrap">
               
		   <a href="https://web.archive.org/web/20071227003250/http://home.germany.net/nils.eilers/zx81/wilfvid.htm" title="0:32:50 Dec 27, 2007"><img src="./ZX81 VIDEO DISPLAY SYSTEM_files/wm_tb_nxt_on.png" alt="Next capture" width="14" height="16" border="0"></a>
	       
	       </td>
           </tr>
           <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
           <tr class="y">
	       <td class="b" nowrap="nowrap">
               
                   <a href="https://web.archive.org/web/20060207090258/http://home.germany.net/nils.eilers/zx81/wilfvid.htm" title="7 Feb 2006"><strong>2006</strong></a>
               
               </td>
               <td class="c" id="displayYearEl" title="You are here: 18:07:56 Aug 30, 2007">2007</td>
	       <td class="f" nowrap="nowrap">
               
	           <a href="https://web.archive.org/web/20140829053455/http://home.germany.net/nils.eilers/zx81/wilfvid.htm" title="29 Aug 2014"><strong>2014</strong></a>
	       
	       </td>
           </tr>
           </tbody></table>
       </td>
       </tr>
       <tr>
       <td class="s">
           <a class="t" href="https://web.archive.org/web/20070830180756*/http://home.germany.net/nils.eilers/zx81/wilfvid.htm" title="See a list of every capture for this URL">16 captures</a>
           <div class="r" title="Timespan for captures of this URL">27 Oct 03 - 5 Mar 16</div>
       </td>
       <td class="k">
       <a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm" id="wm-graph-anchor">
       <div id="wm-ipp-sparkline" title="Explore captures for this URL">
	 <img id="sparklineImgId" alt="sparklines" onmouseover="__wm.st(1)" onmouseout="__wm.st(0)" onmousemove="__wm.mv(event,this)" width="550" height="27" border="0" src="./ZX81 VIDEO DISPLAY SYSTEM_files/graph.jsp">
       <div class="yt" style="display: none; width: 25px; height: 27px;"></div><div class="mt" style="display: none; width: 2px; height: 27px;"></div></div>
       </a>
       </td>
       </tr></tbody></table>
   </td>
   <td class="r">
       <a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm#close" onclick="__wm.h();return false;" style="background-image:url(/static/images/toolbar/wm_tb_close.png);top:5px;" title="Close the toolbar">Close</a>
       <a href="http://faq.web.archive.org/" style="background-image:url(/static/images/toolbar/wm_tb_help.png);bottom:5px;" title="Get some help using the Wayback Machine">Help</a>
   </td>
   </tr></tbody></table>
</div>
</div>
</div>


<!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script type="text/javascript" src="./ZX81 VIDEO DISPLAY SYSTEM_files/disclaim-element.js.download"></script>
<script type="text/javascript" src="./ZX81 VIDEO DISPLAY SYSTEM_files/graph-calc.js.download"></script>
<script type="text/javascript">//<![CDATA[
var __wm = (function(imgWidth,imgHeight,yearImgWidth,monthImgWidth){
var wbPrefix = "/web/";
var wbCurrentUrl = "http://home.germany.net/nils.eilers/zx81/wilfvid.htm";

var firstYear = 1996;
var displayDay = "30";
var displayMonth = "Aug";
var displayYear = "2007";
var prettyMonths = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
var $D=document,$=function(n){return document.getElementById(n)};
var trackerVal,curYear = -1,curMonth = -1;
var yearTracker,monthTracker;
function showTrackers(val) {
  if (val===trackerVal) return;
  var $ipp=$("wm-ipp");
  var $y=$("displayYearEl"),$m=$("displayMonthEl"),$d=$("displayDayEl");
  if (val) {
    $ipp.className="hi";
  } else {
    $ipp.className="";
    $y.innerHTML=displayYear;$m.innerHTML=displayMonth;$d.innerHTML=displayDay;
  }
  yearTracker.style.display=val?"inline":"none";
  monthTracker.style.display=val?"inline":"none";
  trackerVal = val;
}
function trackMouseMove(event,element) {
  var eventX = getEventX(event);
  var elementX = getElementX(element);
  var xOff = Math.min(Math.max(0, eventX - elementX),imgWidth);
  var monthOff = xOff % yearImgWidth;

  var year = Math.floor(xOff / yearImgWidth);
  var monthOfYear = Math.min(11,Math.floor(monthOff / monthImgWidth));
  // 1 extra border pixel at the left edge of the year:
  var month = (year * 12) + monthOfYear;
  var day = monthOff % 2==1?15:1;
  var dateString = zeroPad(year + firstYear) + zeroPad(monthOfYear+1,2) +
    zeroPad(day,2) + "000000";

  $("displayYearEl").innerHTML=year+firstYear;
  $("displayMonthEl").innerHTML=prettyMonths[monthOfYear];
  // looks too jarring when it changes..
  //$("displayDayEl").innerHTML=zeroPad(day,2);
  var url = wbPrefix + dateString + '/' +  wbCurrentUrl;
  $("wm-graph-anchor").href=url;

  if(curYear != year) {
    var yrOff = year * yearImgWidth;
    yearTracker.style.left = yrOff + "px";
    curYear = year;
  }
  if(curMonth != month) {
    var mtOff = year + (month * monthImgWidth) + 1;
    monthTracker.style.left = mtOff + "px";
    curMonth = month;
  }
}
function hideToolbar() {
  $("wm-ipp").style.display="none";
}
function bootstrap() {
  var $spk=$("wm-ipp-sparkline");
  yearTracker=$D.createElement('div');
  yearTracker.className='yt';
  with(yearTracker.style){
    display='none';width=yearImgWidth+"px";height=imgHeight+"px";
  }
  monthTracker=$D.createElement('div');
  monthTracker.className='mt';
  with(monthTracker.style){
    display='none';width=monthImgWidth+"px";height=imgHeight+"px";
  }
  $spk.appendChild(yearTracker);
  $spk.appendChild(monthTracker);

  var $ipp=$("wm-ipp");
  $ipp&&disclaimElement($ipp);
}
return{st:showTrackers,mv:trackMouseMove,h:hideToolbar,bt:bootstrap};
})(550, 27, 25, 2);//]]>
</script>
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  min-width:800px !important;
}
</style>

<script type="text/javascript">__wm.bt();</script>
<!-- END WAYBACK TOOLBAR INSERT -->

<a name="top"></a>
<table width="100%"><tbody><tr><td width="70%">
<h1>ZX81 VIDEO DISPLAY SYSTEM</h1>
<h3>A tutorial by wilf rigter<br>
last revision 7 Sept 1996</h3>
</td><td width="*" valign="top">
<p align="right"><a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvidd.htm"><img src="./ZX81 VIDEO DISPLAY SYSTEM_files/flagd.gif" hspace="10" border="0">This site in German<br>Diese Seite auf Deutsch</a></p>
</td></tr></tbody></table>
<hr>
<a name="index"></a>
<h3>INDEX</h3>
<ol>
<li><a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm#1">INTRODUCTION</a></li>
<li><a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm#2">ZX81 DISPLAY BASICS</a></li>
<li><a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm#3">SLOW MODE VIDEO</a></li>
<li><a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm#4">FAST MODE VIDEO</a></li>
<li><a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm#5">ZX81 VIDEO HARDWARE</a></li>
<li><a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm#6">ZX81 CHARACTER VIDEO HARDWARE</a></li>
<li><a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm#7">PSEUDO HIRES VIDEO HARDWARE</a></li>
<li><a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm#8">TRUE HIRES VIDEO HARDWARE</a></li>
<li><a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm#9">ZX81 CHARACTER DISPLAY TIMING</a></li>
<li><a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm#10">PSEUDO HIRES DISPLAY TIMING</a></li>
<li><a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm#11">TRUE HIRES DISPLAY TIMING</a></li>
<li><a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm#12">ZX81 SLOW MODE VIDEO ROUTINES</a></li>
<li><a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm#13">ZX81 FAST MODE VIDEO ROUTINES</a></li>
<li><a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm#14">TRUE HIRES VIDEO ROUTINES</a></li>
<li><a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm#15">PSEUDO HIRES VIDEO ROUTINES</a></li>
</ol>
<a name="1"></a>
<h3>1.INTRODUCTION</h3>
<p>When circumstances combine innovative technical ideas with an economical design 
  and market opportunity some interesting things begin to happen. In 1980, Sinclair 
  was not yet a household word and was perhaps better known for his digital watch 
  and calculator than his ZX80 personal computer.<br>
  But Sinclair decided the time had come for an affordable and easy to use mass 
  produced version of the ZX80 with floating point math and a non-flicker display.</p>
<p>The ZX81 was born and as they say "the rest is history".</p>
<p>A key to the economical design of the ZX81 was the video system. Not only was 
  it cheap to manufacture, but the ZX81 video circuit turned out to be versatile 
  with capabilities well beyond the designer's original goals.</p>
<a name="2"></a>
<h3>2. ZX81 DISPLAY BASICS</h3>
<p>The standard ZX81 video screen displays 24 rows of 32 characters. Every character 
  has height of 8 scan lines and a width of 8 pixels. The characters to be displayed 
  are located in a block of memory called DFILE. The set of 128 displayable characters 
  includes 64 normal (white on black) uppercase only letters, numbers, symbols 
  and graphics characters and their inverse (black on white). The ZX81 character 
  codes CHR$ 0-63, CHR$118 and CHR$ 128-191, are non-standard (not ASCII). A set 
  of token codes is also used for keywords, functions and commands but these are 
  always expanded to the displayable characters before printing to DFILE. </p>
<p>The DFILE is formatted starting with the Sinclair equivalent of a Carriage 
  Return (CHR$ 118) followed by up to 32 CHR$ codes, this repeated 24 times and 
  ending with a CHR$ 118. CHR$ 118 is the opcode for the Z80 HALT instruction 
  for reasons which will be explained later. </p>
<p>All other character codes are illegal and if loaded into DFILE will generallly 
  cause a system crash. The collapsed DFILE is used in the 1K and 2K basic ZX81 
  to minimize screen memory requirements. When empty a collapsed DFILE consists 
  of just 25 CHR$ 118 codes. Each line is expanded when characters are printed 
  to that line. When equipped with 4K or more of memory, DFILE is initialized 
  to the fully expanded format with 24 lines of 32 CHR$ 00 (space) characters 
  and 25 CHR$ 118 line termination characters.</p>
<p>The character codes are not displayed directly but rather are used as address 
  pointers to a ROM video pattern table. The ROM pattern bytes are addressed by 
  a combination of the character code in DFILE and the ZX81 hardware and is loaded 
  into the video shiftregister. Bit 7 of the character code is used by the video 
  hardware to invert the pixels as they are shifted out of the shift register. 
  The display on the screen is generated by the serial bit stream of pixels a 
  video shift register which turns the TV CRT electron beam on and off as it scans 
  the phosphor coating on the inside face of the picture tube.<br>
</p>
<p>A fully expanded DFILE with 24 lines of 32 characters per row and 8 pattern 
  bytes per character displays 6144 pattern bytes or 49152 pixels per screen.</p>
<a name="3"></a>
<h3>3. SLOW MODE VIDEO</h3>
<p>In the SLOW mode, the CPU is multitasking between video and program execution. 
  About 80% of the CPU time allocated to video and keyboard service routines and 
  only about 20 % of CPU time is available to execute the application program.</p>
<p>In fact, the CPU time is divided in four distinct task blocks per TV frame as 
  shown in TABLE 1. Tasks are switched using a Non Maskable Interupt (NMI) generator 
  to call a NMI service routine which controls task switching from the asynchronous 
  application program to the realtime video routines.</p>
<center>
  <table border="1">
    <tbody><tr> 
      <td>1. </td><td>VSYNC, frame count and keyboard</td><td>NMI off</td>
    </tr>
    <tr> 
      <td>2. </td><td>Blank lines/application code</td><td>NMI on</td>
    </tr>
    <tr> 
      <td>3. </td><td>VIDEO DISPLAY routine</td><td>NMI off</td>
    </tr>
    <tr> 
      <td>4. </td><td>Blank lines/application code</td><td>NMI on</td>
    </tr>
  </tbody></table>
  <i>TABLE 1 SLOW MODE CPU TASK TABLE</i> 
</center>
<p>Each task can be described in more detail as follows:</p>
<ol>
  <li> 
    <p>During the vertical sync interval, when no video is actually displayed, 
      the CPU executes a fixed length VSYNC routine which increments a FRAME counter, 
      reads 8 rows of keyboard data together with the 50/60Hz mode bit. Any I/O 
      read operation with A0 low (ie FE) addresses the ULA keyboard port. It also 
      causes the ULA to start the vertical sync pulse by clamping the video output 
      to the 0V sync level and simultaneously applies a reset to the ULA 3 bit 
      line counter (LCNTR). After the all the keyboard data is processed (400us 
      later), the CPU executes an OUT FF,A (any OUT will do) which restores the 
      ULA video output to the normal "white level with horizontal sync pulses" 
      and releases the LCNTR reset. </p>
    <p>At the end of the VSYNC routine, the number of blank lines to the start 
      of the live display are determined from the system variable MARGIN (50/60HZ). 
      Then the NMI generator is turned on and the CPU registers are switched back 
      to the application task.</p>
  </li><li> 
    <p>While the CPU executes the application code, the CPU is interrupted every 
      64 us by the NMI generator at the same time the ULA generates a horizontal 
      sync pulse. The NMI routine increments a blank line counter in A' and returns 
      if there is more time left for application code excecution. When the blank 
      line counter is incremented to zero the NMI routine turns off the NMI generator 
      and switches to the VIDEO DISPLAY routine through a pointer in the IX register.</p>
  </li><li> 
    <p>The video display routine sets up the display file pointer, the row and 
      line counters, enables INT and JP(HL) to the start of DFILE + 32K. Each 
      character in the DFILE is interpreted as a NOP instruction except the N/L 
      character which terminates the line. At the end of each line, the INT service 
      routine updates the row and line counters and returns to execute the remaining 
      lines. After 192 lines, the video display routine ends by turning on the 
      NMI generator and CPU switches back to execute application code.</p>
  </li><li> 
    <p>As before, during the top blank lines, the NMI routine counts the number 
      of blank lines remaining. At the end of the bottom blank lines, the sequence 
      repeats when the NMI service routine switches back to the VSYNC routine.</p>
</li></ol>
<a name="4"></a>
<h3>4. FAST MODE VIDEO</h3>
<p>In the ZX80 compatable FAST mode, the CPU executes either the video routine 
  or any other program but not both which causes the familiar flicker of the display 
  when switching between these tasks. When the application program is running, 
  it is executed using 100% of the available CPU time. Only if the application 
  program is STOPped (in the command mode) or waiting for a keyboard INPUT, or 
  in PAUSE mode is the video is displayed. </p>
<p>The video hardware is activated in the same way as the SLOW mode but NMI is 
  always off. In addition, the blank lines at the top and bottom of the screen 
  are also generated in software making the ZX81 ROM fully compatable with the 
  ZX80 hardware.</p>
<a name="5"></a>
<h3>5. ZX81 VIDEO HARDWARE</h3>
<p>The ZX81 video hardware consists of the Z80 CPU, ROM, RAM and the larger part 
  of the ZX81 Sinclair Logic Chip (usually called the ULA) as shown in FIG 1 with 
  all relevant connections including the isolation resistors R. For simplicity 
  only the 2K RAM is shown. The ULA contains a 6.5 MHz crystal oscillator and 
  a frequency divider which generates horizontal sync pulses at the video output 
  and NMI pulses on the NMI output. The HSYNC and the NMI outputs can be controlled 
  with the following I/O operations.</p>
<center>
  <table border="1">
    <tbody><tr> 
      <td>1.</td>
      <td>OUT FD,A</td>
      <td>turns off the NMI generator</td>
    </tr>
    <tr> 
      <td>2.</td>
      <td>OUT FE,A</td>
      <td>turns on the NMI generator</td>
    </tr>
    <tr> 
      <td>3.</td>
      <td>IN A,FE</td>
      <td>turns off the HSYNC generator (only if NMI is off)</td>
    </tr>
    <tr> 
      <td>4.</td>
      <td>OUT FF,A</td>
      <td>turns on the HSYNC generator</td>
    </tr>
  </tbody></table>
</center>
<p>&nbsp;</p>
<p>The ULA video output switches between 3 voltage levels. It is normally at the 
  +5V white level for blank lines. Characters patterns are displayed as black 
  pixels when the level is +2.5V . The narrow horizontal sync pulses and wide 
  vertical sync pulses are 0V level as shown in FIG 1 waveform. These logic levels 
  are reduced with a resistor divider to 1V, 0.5V and 0V (UK/US) at the input 
  of the TV RF modulator.</p>
<pre> 

 white _  _____    _____    _________//__________//____             ____//_____
 black _   |   |__|     |__|   |             |         |&lt;--400us--&gt;|          |
 sync  _   |&lt;-------64us------&gt;|&lt;---64us----&gt;|         |_____//____|          |
               display line         blank        blank   vert sync     blank

</pre>
<i>FIG 1 - VIDEO LEVELS</i>
<p>The HSYNC pulses are 5 usec wide with 64 usec between HSYNC pulses. The VSYNC 
  is 400 usec wide with 16.6 msec or 20 msec between VSYNC pulses. VSYNC is used 
  to synchronize the TV vertical oscillator and start the raster scan at the top 
  of the screen. This occurs when IN A,FE (used for scanning the keyboard) clamps 
  the video output to the SYNC level. 400us later OUT FF,A releases SYNC to enable 
  the 64 us HSYNC pulses. The HSYNC pulses continue to be generated independ of 
  the CPU until the next VSYNC. The CPU executes the application code during the 
  blank lines at the top and bottom of the screen while the NMI generator interrupts 
  the CPU every 64 us and increments a blank line counter to determine if it is 
  time for the VIDEO DISPLAY of VSYNC routines.</p>
<a name="6"></a>
<h3>6. ZX81 CHARACTER VIDEO HARDWARE</h3>
<p>The Sinclair ZX81 character display generator consists of the Z80, ROM, RAM 
  and the larger part of the ZX81 Sinclair Logic Chip (usually called the ULA) 
  as shown in FIG 2 with all relevant connections including the isolation resistors 
  R. For simplicity only the 2K RAM is shown.</p>
<pre>              ULA               ROM        Z80        2K RAM
        ________________       _____       _____       _____ 
VIDEO&lt;-| VSHFTREG &lt;-DATA|-----|DATA |-----|DATA |--R--|DATA |  
       |  LINECTR -&gt;A0-2|-----|A0-2 |--R--|A0-2 |-----|A0-2 |
       | CHRLATCH -&gt;A3-8|-----|A3-8 |--R--|A3-8 |-----|A3-8 |
       |                |     |A9-12|-----|A9-13|-----|A9-11|
       |           ROMCS|-----|CE   |     |  INT|-----|A6   |
       |                |     |_____|     |     |     |     |
       |           RAMCS|-----------------|-----|-----|CE/OE|
       |             A14|-----------------|A14  |     |_____|
       |             A15|-----------------|A15  |        
       |              WR|-----------------|WR   | 
       |              RD|-----------------|RD   |
       |              M1|-----------------|M1   |
       |            MREQ|-----------------|MREQ |
       |            IORQ|-----------------|IORQ | 
       |             NMI|-----------------|NMI  |   
       |            HALT|-----------------|HALT |
       |________________|                 |_____| 

</pre>
<i>FIG 2 ZX81 CHARACTER VIDEO DISPLAY CIRCUIT</i>
<a name="7"></a>
<h3>7. PSEUDO HIRES VIDEO HARDWARE<br>
</h3>
<p>The pseudo hires graphics video display generator consists of the Z80 CPU, 
  ROM, RAM and a large part of the ZX81 Sinclair Logic Chip (usually called the 
  ULA) as shown in FIG 2 with all relevant connections including the isolation 
  resistors R. For simplicity only the 2K RAM is shown.</p>
<pre>              ULA               ROM        Z80        2K RAM
        ________________       _____       _____       _____ 
VIDEO&lt;-| VSHFTREG &lt;-DATA|-----|DATA |-----|DATA |--R--|DATA |  
       | *LINECTR -&gt;A0-2|-----|A0-2 |--R--|A0-2 |-----|A0-2 |
       | CHRLATCH -&gt;A3-8|-----|A3-8 |--R--|A3-8 |-----|A3-8 |
       |                |     |A9-12|-----|A9-13|-----|A9-11|
       |           ROMCS|-----|CE   |     | *INT|-----|A6   |
       |                |     |_____|     |     |     |     |
       |           RAMCS|-----------------|-----|-----|CE/OE|
       |             A14|-----------------|A14  |     |_____|
       |             A15|-----------------|A15  |        
       |              WR|-----------------|WR   | 
       |              RD|-----------------|RD   |
       |              M1|-----------------|M1   |
       |            MREQ|-----------------|MREQ |
       |            IORQ|-----------------|IORQ | 
       |             NMI|-----------------|NMI  |   
       |            HALT|-----------------|HALT |
       |________________|                 |_____| 

</pre>
<i>FIG 3 PSEUDO HIRES GRAPHICS DISPLAY CIRCUIT</i>
<p>The only difference between pseudo hiress and Sinclair character hardware is 
  the *ULA LCNTR and the use of the *INT input. Most pseudo hires core routines 
  do not use INT and the ULA LCNTR is reset to zero every horizontal line. The 
  exception is XTRICATOR which uses INT and makes dual use of the I register in 
  INT mode 2 as a part of the RST vector address when interupted at the end of 
  each horizontal line and at refresh time as a ROM pattern table pointer.</p>
<a name="8"></a>
<h3>8. TRUE HIRES VIDEO HARDWARE</h3>
<p>The portion of the ZX81 hardware required for true hires graphics display consists 
  of the Z80 CPU, the RAM, the video shift register and the sync circuit of the 
  ULA as shown in FIG 4 with all relevant connections. Again the 2K SRAM is shown 
  for simplicity but applies to larger SRAM designs as well. If a 16K RAMPACK 
  is used, this must be slightly modified, as will be shown later, to enable the 
  data outputs during RFSH time as required for this hires display method.</p>
<pre>              ULA               ROM         Z80       2K RAM
        ________________       _____       _____       _____ 
VIDEO&lt;-| VSHFTREG &lt;-DATA|-----|DATA |-----|DATA |--R--|DATA |
       |                |     |A0-12|-----|A0-15|-----|A0-10|
       |           ROMCS|-----|CE   |     |     |     |     |
       |                |     |_____|     |     |     |     |
       |           RAMCE|-----------------|-----|-----|CE/OE|
       |             A14|-----------------|A14  |     |_____|
       |             A15|-----------------|A15  |
       |              WR|-----------------|WR   |
       |              RD|-----------------|RD   |
       |              M1|-----------------|M1   |
       |            MREQ|-----------------|MREQ |
       |            IORQ|-----------------|IORQ |
       |             NMI|-----------------|NMI  |
       |            HALT|-----------------|HALT |
       |________________|                 |_____|

</pre>
<i>FIG 5 TRUE HIRES GRAPHICS VIDEO DISPLAY CIRCUIT</i>
<p>With the exception of WRX1K which creates a miniature hires screen on a 1K 
  ZX81 all hires programs need a 6K hires graphics file (HFILE). Suitable RAM 
  for true hires graphics can be implimented by modifying a standard 16K RAMPACK 
  with a couple of diodes and a resistor.</p>
<p>The RAMPACK is modified to enable the data output at RFSH time by cutting the 
  RD and RFSH lines at the edge connector and installing 2 only 1N34A Germanium 
  diodes and a 4.7K pullup resistor. Modify at your own risk!</p>
<pre>                            +5V
                             |
                           [4.7K]
                     1N34A   |
connector   RD _______|/|____|_____________ RD OF RAMPACK
                      |\|    |
                             |
connector RFSH _______|/|____|     +5V_____ RFSH of RAMPACK
                      |\|
                     1N34A
</pre>
<i>FIG 5 RAMPACK MODIFICATION FOR TRUE HIRES</i>
<a name="9"></a>
<h3>9. ZX81 CHARACTER DISPLAY TIMING</h3>
<p>All the Sinclair ZX81 character display hardware shown in FIG 2 is required 
  to generate a standard screen of 24 lines of 32 characters. The character display 
  starts when the last blank line at the top of the screen has occurred and and 
  the video routine jumps to the DFILE echo above 32K. The hardware in the ZX81 
  ULA takes control when any opcode is executed above 32K (A15 high and M1 low) 
  with data bit 6 equal to zero. The video data is loaded in these simplified 
  steps:</p>
<ol>
  <li>The ULA loads the character code into a address register in the ULA 
  </li><li>The ULA forces the data lines low. 
  </li><li>The CPU interprets the byte as a NOP. 
  </li><li>The ULA generates part of the ROM pattern table address and the Z80 CPU 
    generates the pattern table pointer with the I register. 
  </li><li>The pattern byte is loaded into the ULA shift register. 
</li></ol>
<p>One could say that the Dfile is literally executed with NOPs substituted for 
  each character code. Each NOP executes in 4 CPU clock cycles at 3.25 MHz or 
  8 pixels at 6.5MHz from the ULA video shift register.</p>
<pre>           &lt;--------CHARACTER 1-----------&gt;&lt;--------CHARACTER 2-----------&gt;
   T STATE &lt;--T1--&gt;&lt;--T2--&gt;&lt;--T3--&gt;&lt;--T4--&gt;&lt;--T1--&gt;&lt;--T2--&gt;&lt;--T3--&gt;&lt;--T4--&gt;
     (ref)  ___    1___2   3___     ___5    ___     ___     ___     ___
 CPU CLOCK |   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|
           _ _______________ _______________ _______________ _______________
    A0-A15 _X_____PC________X___I+CHR+ULA___X______PC_______X___I+CHR+ULA___X
                ________  NOP  __________       ________  NOP  __________
      DATA &gt;---|__CHR___|_____|_ROM DATA_|-----|__CHR___|_____|_ROM DATA_|--

</pre>
<i>FIG 6 ZX81 CHARACTER DISPLAY TIMING</i>
<p>The detailed sequence of operations for each character byte is shown in FIG 
  6 and described as follows:</p>
<ol>
  <li>Each character code (CHR$) byte in DFILE is addressed by the CPU PC, on 
    the rising edge T2 data is loaded from DFILE into the ULA : bits 0-5 into 
    a 6 bit ULA address latch while bit 7 is loaded into 1 bit ULA video invert 
    latch 
  </li><li>On the falling edge of T2, the ULA forces all CPU data lines to zero. 
  </li><li>On the rising edge of T3 the low data lines are interpreted by the CPU as 
    a NOP instruction. 
  </li><li>During T3/4, the CPU executes the Refresh cycle and ROM address lines are 
    generated with I register on A9-A15, the ULA 6 bit character code register 
    on A3-A8, and the ULA modulo 8 line counter on line A0-A2. 
  </li><li>On the falling edge of T4, pattern data from the ROM is loaded into ULA 
    video shift register and 8 video pixels are shifted out at 6.5MHz 
  </li><li>If character code bit 7 latch in ULA equals 1, video pixels are inverted. 
  </li><li>The CPU increments the program counter and fetches the next character code. 
  </li><li>This repeats until a HALT (Sinclair) is fetched. 
  </li><li>HALT opcode bit 6 = 1 and is therefore executed (no NOP) 
  </li><li>The ULA generates a HSYNC pulse independend of the CPU timing and the ULA 
    LCNTR is incremented 
  </li><li>The halted CPU continues to execute NOPs, incrementing register R and samples 
    the INT input on the rising edge of each T4. 
  </li><li>When A6, which is hardwired to INT, goes low during refresh time, (bit 6 
    of the R reg = 0), the Z80 executes the INT routine (below 32K) 
  </li><li>CPU returns from INT and resumes "excution" of DFILE CHR$ codes. 
  </li><li>The process repeats 192 times and then INT routine returns to the main video 
    routine, turns on the NMI generator and switches back to the application code. 
</li></ol>
<a name="10"></a>
<h3>10. PSEUDO HIRES DISPLAY TIMING</h3>
<p>All the ZX81 character display hardware shown in FIG 2 with some exceptions 
  is required to generate a standard screen of 192 lines of 32 pseudo hires patterns. 
  The display starts when the last blank line at the top of the screen has occurred 
  and and the video routine jumps to the 6K DFILE echo above 32K. The hardware 
  in the ZX81 ULA takes control when any opcode is executed above 32K (A15 high 
  and M1 low) with data bit 6 equal to zero.<br>
</p>
<p>The video data is loaded in five steps:</p>
<ol>
  <li>The ULA loads the character code into an address register 
  </li><li>The ULA forces the data lines low. 
  </li><li>The CPU interprets the byte as a NOP. 
  </li><li>The ULA generates part of the ROM pattern table address. The CPU generates 
    the pattern table MSB address with the I register. 
  </li><li>The quasi hires pattern byte is loaded into the ULA shift register. 
</li></ol>
<p>Each NOP executes in 4 CPU clock cycles at 3.25 MHz or 8 pixels at 6.5MHz from 
  the ULA video shift register.</p>
<pre>           &lt;--------CHARACTER 1-----------&gt;&lt;--------CHARACTER 2-----------&gt;
   T STATE &lt;--T1--&gt;&lt;--T2--&gt;&lt;--T3--&gt;&lt;--T4--&gt;&lt;--T1--&gt;&lt;--T2--&gt;&lt;--T3--&gt;&lt;--T4--&gt;
     (ref)  ___    1___2   3___     ___5    ___     ___     ___     ___
 CPU CLOCK |   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|
           _ _______________ _______________ _______________ _______________
    A0-A15 _X_____PC________X___I+CHR+ULA___X______PC_______X___I+CHR+ULA___X
                ________  NOP  __________       ________  NOP  __________
      DATA &gt;---|__CHR___|_____|_ROM DATA_|-----|__CHR___|_____|_ROM DATA_|--

</pre>
<i>FIG 7 SINCLAIR CHARACTER DISPLAY TIMING</i>
<p><br>
  The detailed sequence of operations for each character byte is as follows:</p>
<ol>
  <li>Each character code (CHR$) byte in DFILE is addressed by the CPU PC, on 
    the rising edge T2 data is loaded from DFILE into the ULA : bits 0-5 into 
    a 6 bit ULA address latch while bit 7 is loaded into 1 bit ULA video invert 
    latch 
  </li><li>On the falling edge of T2, the ULA forces all CPU data lines to zero. 
  </li><li>On the rising edge of T3 the low data lines are interpreted by the CPU as 
    a NOP instruction. 
  </li><li>During T3/4, the CPU executes the Refresh cycle and ROM address lines are 
    generated with I register on A9-A15, the ULA 6 bit character code register 
    on A3-A8, and zero on line A0-A2. 
  </li><li>On the falling edge of T4, pattern data from the ROM is loaded into ULA 
    video shift register and 8 video pixels are shifted out at 6.5MHz 
  </li><li>If character code bit 7 latch in ULA equals 1, video pixels are inverted. 
  </li><li>The CPU increments the program counter and fetches the next character code. 
  </li><li>This repeats until a RET fetched which returns to the hires routine. 
  </li><li>RET opcode bit 6 = 1 and is therefore executed (no NOP) 
  </li><li>The ULA generates a HSYNC pulse independend of the CPU timing and the ULA 
    LCNTR is incremented but the video software resets the LCNTR to zero. 
  </li><li>CPU returns from the hires routine and resumes "excution" of DFILE 
    CHR$ codes. 
  </li><li>The process repeats 192 times and then hires routine ends by turning on 
    the NMI generator and by switching back to the application code. 
</li></ol>
<a name="11"></a>
<h3>11. TRUE HIRES DISPLAY TIMING</h3>
<p>Although I will use the WRX hires core routine as an example, the true hires 
  software developed independently by others is very similar. The true hires display 
  starts when the last blank line at the top of the screen has occurred, and NMI 
  jumps via IX to the HR video routine. HR sets up the I and R register pointers 
  to the hires display file (HFILE), then the HR routine jumps to the LBUF routine 
  echo above 32K and loads register R and points to the first NOP opcode. The 
  ULA loads the video shift register when any opcode is executed with A15 high 
  and M1 low and data bit 6 equal to zero.</p>
<p>The hires data is loaded in 3 steps:</p>
<ol>
  <li> The CPU executes each of the 4T state NOP instructions.</li>
  <li> During T3/4 (refresh), the I and R registers appear on the A0-15 lines.</li>
  <li> The hires byte addressed by I and R is loaded into the ULA shift register.</li>
</ol>
<p>LBUF consists 32 NOP opcodes, each executing in 4 CPU clock cycles. During 
  the second part of the opcode excution, the I and R register address the hires 
  byte in HFILE which the ULA loads into the video shift register. The ULA generated 
  ROM address for the pattern table is not used since ROMCS is not enabled as 
  register I (A8-15) is set up to point to the RAM based HFILE.</p>
<pre>           &lt;---------HIRESBYTE1-----------&gt;&lt;---------HIRESBYTE2-----------&gt;
   T STATE &lt;--T1--&gt;&lt;--T2--&gt;&lt;--T3--&gt;&lt;--T4--&gt;&lt;--T1--&gt;&lt;--T2--&gt;&lt;--T3--&gt;&lt;--T4--&gt;
            ___     ___     ___     ___     ___     ___     ___     ___
 CPU CLOCK |   |___|   |___|   |___|   |___|   |___|   |___|   |___|   |___|
           _ _______________ _______________ _______________ _______________
    A0-A15 _X______PC_______X______I_+_R____X______PC_______X______I_+_R____X
                ____________    _________       ____________    _________
      DATA &gt;---|_____NOP____|--|__HIRES__|-----|_____NOP____|--|__HIRES__|--

</pre>
<i>FIG 8 TRUE HIRES DISPLAY TIMING</i>
<p>The detailed sequence of operations for each HIRES byte is as follows:</p>
<ol>
  <li>The first opcode of the LBUF routine, LD R,A is executed.</li>
  <li> The following 32 NOPs in LBUF are sequentially executed.</li>
  <li>On the rising edge of T3 of each instruction fetch, the CPU executes the 
    NOP.</li>
  <li> During T3/4, the address is generated with the R register on A0-7 and the 
    I register on A8-A15.</li>
  <li> On the falling edge of T4, a hires data byte from HFILE is loaded into 
    ULA video shift register and 8 video pixels are shifted out at 6.5MHz</li>
  <li> The CPU increments the program counter and the R register and fetches the 
    next NOP and the next hires byte.</li>
  <li> This process repeats 32 times.</li>
  <li> The last opcode of LBUF, JP (IX), is executed to return to the HR routine</li>
  <li> The ULA generates a horizontal syncpulse.</li>
  <li>The HLINE routine increment the I/R register pair by 32 and jumps back to 
    the 32 NOP LBUF routine echo above 32K.</li>
  <li>The process repeats 192 times.</li>
  <li>The HIRES video routine may call the Sinclair character routine for the 
    bottom line and restores the registers etc to return to the application code.</li>
</ol>
<p>Like the other hires routines WRX intercepts the Sinclair video by loading 
  a new video routine vector in the IX register.</p>
<a name="12"></a>
<h3>12. ZX81 SLOW MODE VIDEO ROUTINES</h3>
<p>As shown in TABLE 1 the CPU is multitasking between the video routines and 
  the application program in 4 blocks of time.</p>
<h4>1. VSYNC INTERVAL ROUTINES</h4>
<table border="1" width="70%">
  <tbody><tr> 
    <td width="5%">0229 </td>
    <td width="15%">DISPLAY-1 </td>
    <td width="*">DECREMENT FRAME COUNTER</td>
  </tr>
  <tr> 
    <td>023E </td>
    <td>DISPLAY-2 </td>
    <td>CHECK KEYBOARD (START OF VSYNC)</td>
  </tr>
  <tr> 
    <td>0277 </td>
    <td>OUT FF,A </td>
    <td>ENDS THE VSYNC PULSE</td>
  </tr>
  <tr> 
    <td>0292 </td>
    <td>DISPLAY-3 </td>
    <td>SAVE THE VIDEO POINTER IN IX (0281), RETURN TO APPLICATION</td>
  </tr>
</tbody></table>
<h4>2. APPLICATION PROGRAM</h4>
<table border="1" width="70%">
  <tbody><tr> 
    <td width="5%">0066 </td>
    <td width="15%">NMI </td>
    <td width="*">COUNTS BLANK LINES, RETURN TO APPLICATION OR VIA JP (IX) TO 0281</td>
  </tr>
</tbody></table>
<h4>3. DFILE DISPLAY ROUTINES</h4>
<table border="1" width="70%">
  <tbody><tr> 
    <td width="5%">0281 </td>
    <td width="15%">VIDEO-1 </td>
    <td width="*">SETUP DISPLAY PARAMETERS, CALL 2B5 (RETURN VIA INT)</td>
  </tr>
  <tr> 
    <td>02B5 </td>
    <td>DISPLAY-5 </td>
    <td>SETUP DISPLAY PARAMETERS, ENABLE INTERRUPT, JP (DFILE)</td>
  </tr>
  <tr> 
    <td>XXXX </td>
    <td>(DFILE) </td>
    <td>EXECUTES HALTs AND FORCED NOPs IN DFILE</td>
  </tr>
  <tr> 
    <td>0038 </td>
    <td>INT </td>
    <td>DECREMENTS ROW/LINES COUNTERS RETURN TO DFILE OR TO 028B</td>
  </tr>
  <tr> 
    <td>0292 </td>
    <td>DISPLAY-3 </td>
    <td>SAVE VIDEO POINTER (028F)</td>
  </tr>
</tbody></table>
<h4>4. APPLICATION PROGRAM</h4>
<table border="1" width="70%">
  <tbody><tr> 
    <td width="5%">0066 </td>
    <td width="15%">NMI </td>
    <td width="*">COUNTS BLANK LINES, RETURN TO APPLICATION OR VIA JP (IX) TO 028F</td>
  </tr>
  <tr> 
    <td>028F </td>
    <td>VIDEO-2 </td>
    <td>JP 229 BACK TO FRAME COUNTER in BLOCK 1</td>
  </tr>
</tbody></table>
<p>The ZX81 video routines follow in fully anotated listings showing more details 
  than IAN LOGAN ZX81 DISASSEMBLY. Needless to say, I used Dr. LOGAN's book extensively 
  during my research into the ZX81 video code.</p>
<p>NOTE: Only code which is relevant to video is shown here.</p>
<pre>0038               ;INT SERVICE ROUTINE
     DEC C         ;decrement the scan line counter in register C
     JP NZ 0045    ;go SCAN-LINE : repeats 8 times for each DFILE character row
     POP HL        ;point to the start of next DFILE row
     DEC B         ;decrement the ROW counter in register B
     RET Z         ;return to 028B
     SET 3,C       ;load scan line counter in register C with 08 scan lines

0041               ;WAIT-INT
     LD R,A        ;load value DD into register R
     EI            ;enable INT
     JP (HL)       ;execute the NOPs in DFILE

0045               ;SCAN-LINE
     POP DE        ;discard the return address
     RET Z         ;delay (never returns)
     JR 0041       ;got WAIT-INT
                   ;----------------------------------------------------------

0066               ;NMI SERVICE ROUTINE
                   ;Interupts application program every 64 usec (HSYNC)
     EX AF,AF'     ;retrieve blank line counter in AF'
     INC A         ;next blank line
     JP M 006D     ;RETURN via 006D if AF' = FF (to NMI-EXIT)
     JR Z 006F     ;JR NMI-CONT if last line
006D EX AF,AF'     ;save blank line counter
     RET           ;return to application or NMI-EXIT

006F               ;NMI-CONT
     EX AF,AF'     ;retrieve main register AF
     PUSH AF       ;now save the application program registers
     PUSH BC
     PUSH DE
     PUSH HL
     LD HL,(DFILE) ;needed only if IX=0281 and
     SET 7,H       ;if DFILE is executed
     HALT          ;1T state synchronization: this HALT is used with special
                   ;hardware connected to the CPU WAIT and HALT lines and is
                   ;released and synchronized on the falling of the NMI pulse

007A               ;NMI-EXIT
     OUT FD,A      ;turn off NMI generator
     JP (IX)       ;to VIDEO-1 or VIDEO-2
                   ;---------------------------------------------------------

0229               ;DISPLAY-1
     LD HL,(FRAMES);get the system variable FRAMES
     DEC HL        ;decrement each frame
     .....
     LD (FRAMES),HL;save the system variable FRAMES

023E               ;DISPLAY-2
     CALL 02BB     ;read the keyboard and load MARGIN with blank lines
     .....         ;also starts the VSYNC pulse
0277 OUT FF,A      ;stops the VSYNC pulse
     LD HL,(DFILE) ;(FAST VIDEO only) - point HL to first HALT for blank lines
     SET 7,H       ;(FAST VIDEO only) - DFILE echo above 32K
027E CALL 0292

0281               ;VIDEO-1
                   ;this vector is saved in register IX at 0292
     LD A,R        ;delay
     LD BC,1901    ;set up INT parameters for first HALT at (DFILE)
     LD A,F5       ;set up R register for first HALT at (DFILE)
     CALL 2B5      ;continue setup for DFILE display and return via INT
028B               ;return here from last INT
     DEC HL        ;(FAST VIDEO only) - point HL to last HALT for blank lines
     CALL 292      ;save VIDEO vector in IX, calculate blank lines, POP regs

028F JP 0229       ;VIDEO-2
                   ;this vector is saved in register IX at 0292

0292               ;DISPLAY-3
     POP IX        ;IX=0281 or 028F to vestor to VIDEO-1 or VIDEO-2
     LD C,(IY+56)  ;load number of blank lines from MARGIN (1F in 60 Hz option)
     BIT 7,(IY+59) ;test FAST/SLOW bit
     JR Z,2A9      ;(FAST VIDEO)  branches to generate blank lines
     LD A,C        ;C=(MARGIN)=1F for 60 Hz
     NEG           ;
     INC A         ;
     EX AF,AF'     ;during NMI @ 0066 - AF' is incremented and tested for zero
     OUT (FE),A    ;turn on NMI generator
     POP HL        ;self explanatory
     POP DE
     POP BC
     POP AF
     RET           ;return to application program interupted every HSYNC by NMI
                   ;-----------------------------------------------------------

02B5               ;DISPLAY-5
     LD R,A        ;R increments with each opcode on A0 to A7 during RFSH
                   ;until A6 goes low which generates the INT signal.
     LD A,DD       ;Set the left margin of all other lines, load to R at 0041
     EI            ;Now that R is set up enable INT
     JP (HL)       ;"executes" the DFILE starting with HALT and waits for the
                   ;first INT to come to the rescue.
                   ;-----------------------------------------------------------

</pre>
<a name="13"></a>
<h3>13. ZX81 FAST MODE VIDEO ROUTINES</h3>
<p>In order to speed up application program execution time, the FAST mode uses 
  100% of the CPU time for executing the application program but there are times 
  when the application program is idle. When the program is STOPped or PAUSEd 
  or waiting for keyboard INPUT, the keyboard is checked and if no key is down 
  the video is generated independent of NMI pulses.<br>
</p>
<p>In fact, the ZX81 FAST mode video routine was designed to be compatable with 
  the ZX80 hardware so the ROM could be used as a retrofit ROM upgrade.<br>
</p>
<p>Since the ZX80 generates the blank lines in software, the ZX81 ROM does the 
  same when in the FAST mode.</p>
<p>The loop of VIDEO routines for FAST video starts with the FRAME/KBD/VSYNC routine 
  at 229:</p>
<pre>   0229 DECREMENT FRAME COUNTER
   023D EXIT FAST VIDEO IF FRAMES=0 (END OF PAUSE)
   023E CHECK KEYBOARD
   0260 EXIT FAST VIDEO IF NEW KEY PRESSED
   0292 SAVE THE VIDEO POINTER IN IX (0281)
   029B JR Z 02A9 TO BLANK LINE ROUTINE
   02A9 GENERATE BLANK LINES
   02B3 JP (IX) TO 0281
   0281 GENERATE THE DFILE DISPLAY
   0292 SAVE VIDEO POINTER (028F)
   029B JR Z 02A9 TO BLANK LINE ROUTINE
   02A9 GENERATE BLANK LINES
   02B3 JP (IX) TO 028F)
   028F JP 229 BACK TO FRAME COUNTER
</pre>
<p>Since most of the routines were described in the SLOW MODE VIDEO chapter, only 
  the differences are described here. Compare the way the SLOW mode enters this 
  loop from end of blank line application program execution by saving the main 
  registers of the program and restoring them at the end of 0292. By contrast, 
  the FAST mode does not save any registers and branches out of the 0292 restore 
  main register routine to literally generate the blank lines. This is done at 
  029B after testing the FAST flag and jumping to a less known routine called 
  DISPLAY-4</p>
<pre>02A9 ;DISPLAY-4
   LD A,FC        ; first R delay to INT
   LD B,01        ; one row
   CALL 02B5      ; display blank lines
   DEC HL         ; point back to HALT
   EX (SP),HL     ; delay 19T
   EX (SP),HL     ; delay 19T
   JP (IX)        ; IX = 0281 or 028F
</pre>
<p> The routine at 02A9 is called twice each frame to generate the top and bottom 
  blank lines with HL pointing to either the first HALT at the start of DFILE 
  or the last HALT at end of DFILE. Reg C holds the number of blank lines and 
  reg B is set up for 1 row. After VSYNC the 31 top blank lines are generated 
  by calling the diplay routine at 02B5 and excecuting the first HALT at the START 
  of DFILE 31 times. After returning from the display routine HL points to the 
  last HALT+1 and DEC HL is required point HL back to the last HALT of DFILE. 
  After saving the return address in IX, the routine at 029A is reentered with 
  HL pointing to the last HALT and generates the bottom 31 blank lines by excecuting 
  the HALT at the END of DFILE.</p>
<p>&nbsp;</p>
<a name="14"></a>
<h3>14. TRUE HIRES VIDEO SOFTWARE</h3>
<p>The true hires core routines are distinguished by the use of the I and R register 
  pair as address pointers for the display file. The only other requirement is 
  to execute 32 NOP instructions (or equal) per horizontal line and to update 
  the I and R registers during HSYNC time. More blank lines can be used above 
  and below the display for faster application execution. The listings are compatable 
  source code for the ZXAS assembler both on the ZX81 and under XTender, the ZX81 
  emulator form CARLO DELHEZ.<br>
</p>
<p>Check current version of XTender for hires compatability.<br>
</p>
<p>These ASCII listings can be used to prepare a formatted 2 REM .l file with 
  the ZXAS.COM program from Jack Raats.</p>
<h4><br>
  WRX16 - 1984 wilf rigter</h4>
<p>This is the hires core used in programs by FRED NACHBAUR and GREG HARDER. It 
  creates a 256x192 high resolution display in a 6144 byte array starting at (HFILE), 
  which can be poked directly from BASIC programs. START is used to start the 
  hires display and STOP restores the SINCLAIR video. It has a characteristic 
  signature with the I register value greater than 2000 hex. PART 1 calls LBUF 
  192 times, displaying 256x192 pixels, calculates blank lines, saves pointer 
  to PART 2 in IX and returns to application code. PART 2 calls VSYNC etc, calculates 
  blank lines, saves pointer to PART 2 in IX and returns to application code execution.</p>
<pre>      ;ORIGIN = 16516 (hex 4084)

LBUF  ;Displays one line of 256 pixels
      ;------------------------------

      ;like DFILE, it is called above 32K to activate the ULA video
      ;hardware. The hires bytes may be inverted for special effects
      ;by setting bit 7 of the NOP codes . The hires data is loaded
      ;into the ULA video shift register during the refresh cycles of
      ;the 32 NOP opcodes when the I and R registers sequentially
      ;address 32 bytes of hires data in the 6144 byte HFILE

LBUF
      LD R,A     ;Now load R register
      00 00 00 00;32 bytes of 8 pixels
      00 00 00 00
      00 00 00 00
      00 00 00 00
      00 00 00 00
      00 00 00 00
      00 00 00 00
      00 00 00 00
      JP (IX)    ;Return to HR


HR    ;HIRES DISPLAY ROUTINE PART 1
      ;----------------------------
      LD B,04    ;load delay
HR0   DJNZ HR0   ;delay 56T states to synchronize with HSYNC pulses.
      LD HL,(HFILE);RAMTOP points to the first HFILE byte
      LD B,C0    ;48 horizontal lines
      LD IX,HR1  ;save the return vector in IX (for JP (IX) at end of LBUF)
      JR HR2     ;skip HR1 first time through the loop
HR1   LD DE,20   ;this value for 32 bytes or 256 pixels per line is
      ADD HL,DE  ;added to HL to point to the start of the next HLINE
      DEC B      ;repeat 48 times
      JP Z HR3   ;if this is the last line JP to HR3
HR2   LD A,H     ;the address in HL is then transferred to
      LD I,A     ;I register
      LD A,L     ;and during LBUF to the R register
      JP C084    ;jump to LBUF @ 4084 + 8000 to start the ULA
HR3   LD IX,HR4  ;save the video vector so that NMI returns to HR4
      JR HR5     ;now get blank lines and return to application code

HR4   ;HIRES DISPLAY ROUTINE PART 2
      ;----------------------------
      CALL 220   ;first PUSH registers then jump to VSYNC, etc
      LD IX,WRX16;save the video vector so that NMI returns to HR
HR5   LD A,(4028);33 or 19 blank lines in system variable MARGIN
      JP 29E     ;save blank lines, start NMI, POP registers and RETURN

      ;--------------------- end of listing ---------------------

The hires video is started and stopped by changing the vector address
in register IX which is used by NMI to JP (IX) to the video routine.
The following routines are synchronized with the display so that the
changeover in video mode occurs without display breakup.

STOP  ;STOP hires video and return to SINCLAIR video
      ;---------------------------------------------
      LD HL,0281 ;pointer to SINCLAIR video routine
      LD A,1E    ;SINCLAIR ROM pattern table MSB base address (1E00)
      LD I,A     ;pointer to I register
      JR SYNC

START ;Start the hires video
      ;---------------------
      LD HL,HR   ;pointer to the hires video routine

SYNC  ;used by START and STOP to smoothly change video mode
      ;----------------------------------------------------
      PUSH HL
      LD HL,4034 ;FRAMES counter
      LD A,HL    ;get old FRAMES
SYNC1 CP A,(HL)  ;compare to new FRAMES
      JR Z SYNC1 ;exit after a change is detected
      POP IX     ;SINCLAIR video routine


     ;-------------- END OF LISTING ---------------
</pre>
<h4>GUUS-FLATER by ENNO BORGESTEEDE (1984)</h4>
<p>This hires core uses a ingenious way to intercept the video vector. Instead 
  of changing the value of the IX register, GUUS-FLATER intercepts at the beginning 
  of the DFILE execution by changing the first 4 bytes including the HALT to DI 
  and JP 409F which is the start of the hires routine. At the end of the hires 
  screen the program simply returns to ROM routine at xxxx. It has a characteristic 
  DFILE starting with the DI and JP 409F and the HFILE starts at (4004)</p>
<pre>(400C)  DI           ;these bytes are loaded into DFILE
        JP 409F      ;to vector to the hires routine

409F    LD B,08      ;delay
40A1    DJNZ 40A1    ;delay
        LD A,R       ;delay
        LD B,C0      ;192 lines
        LD DE,20     ;32 bytes per line
        LD HL,(4004) ;hires file (HFILE) starts at RAMTOP
40AD    LD A,H       ;MSB address of HFILE
        LD I,A       ;load MSB of HFILE pointer
        LD A,L       ;LSB address of HFILE
40B3    JP C0B6      ;JUMP above 32K
40B6    LD R,A       ;load LSB of HFILE pointer
40B8    "COPYRIGHT 1984 ENNO BORGESTEEDE " ; same as 32 NOPs
40D8    JP 40DB      ;JUMP below 32K
40DB    ADD HL,DE    ;next hires line
40DC    DJNZ 40AD    ;next line repeats 192 times
40DE    LD A,1E      ;restore ROM pattern table pointer
40E0    LD I,A       ;load pointer
40E2    RET          ;join the SINCLAIR video in progress
</pre>
<h4>HRG7 - in progress</h4>
<h4>WRX16K - 1996 wilf rigter &lt;<a href="mailto:rigter@cafe.net">rigter@cafe.net</a>&gt;</h4>
<p>The original WRX was written in 1984 but recent renewed interest has yielded 
  newer more efficient versions. WRX16K 1996 is the most compact version of the 
  WRX yet and will display a true bit mapped 256x192 hires screen. It was designed 
  to work with the modified 16K RAMPACK or 16K SRAM and you must first lower RAMTOP 
  with POKE 16389,96 then NEW before loading. </p>
<p>The hires mode can be started and stopped with the same routines shown in the 
  WRX16 listing above. The simple START is used for starting the hires mode by 
  changing video vector address in the IX register. Hires is stopped with the 
  inline code segment called "BREAK" which returns synchronously to 
  the Sinclair video mode when the space key is pressed. The HFILE is a 6K linear 
  array starting at (4004) but is easily relocated.<br>
</p>
<p>Note that HFILE must start on a 32 byte boundary (2000,2020, etc).</p>
<pre>ORG   16516       ;(hex 4084)

START LD IX,HR    ;simple start of the hres mode
      RET

LBUF LD R,A       ;load HFILE address LSB
      0 0 0 0     ;32 NOPs = 256 pixels
      0 0 0 0 
      0 0 0 0 
      0 0 0 0 
      0 0 0 0 
      0 0 0 0 
      0 0 0 0
      0 0 0 0
      RET NZ      ;always returns

HR    
      LD B,7      ;delay
HR0   DJNZ HR0    ;delay
      DEC B       ;reset Z flag
      LD HL,(4004);HFILE starts at RAMTOP or HSCRN (note below)
      LD DE,20    ;32 bytes per line
      LD B,C0     ;192 lines per hires screen
HR1   LD A,H      ;get HFILE address MSB
      LD I,A      ;load MSB into I register
      LD A,L      ;get HFILE address LSB
      CALL C089   ;CALL LBUF + 8000
      ADD HL,DE   ;next line
      DEC B       ;dec line counter
      JP NZ HR1   ;last line
HR2   
      CALL 292    ;return to application program
      CALL 220    ;extra register PUSH and VSYNC
BREAK             ;this code segment is optional
      CALL F46    ;check break key
      LD A,1E     ;restore pattern table pointer
      LD I,A
      JR NC STOP  ;skip the HR vector load if BREAK
      LD IX,HR    ;load the HR vector
STOP  JP 2A4      ;return to application program

HSCRN 2000        ;this is used with SRAM at 8K - 16K

;------------------ end of listing ------------------
</pre>
<p>Note: HFILE can be relocated to use SRAM between 8 to 16K by changing
LD HL,(4004) to LD HL,(HSCRN).</p>

<h4>WRX1K -1996 wilf rigter</h4>
<p>This little true hires program is special because it runs on a 1K/2K ZX81.<br>
  It creates a miniature 64x48 high resolution display in a 384 byte array<br>
  starting at (RAMTOP), which can be poked directly from BASIC programs.<br>
  When START is called, it collapses the SINCLAIR DFILE and expands<br>
  the hires file above RAMTOP in order to efficiently utilize the 1K memory.<br>
  When STOP is called, it recovers the space above RAMTOP to make more RAM<br>
  avialable for DFILE.</p>
<pre>      ;ORIGIN = 16516 (hex 4084)

LBUF  ;Dummy display file
      ;------------------

      ;like DFILE, it is called above 32K to activate the ULA video
      ;hardware but only bit 7 character code data is used. The hires
      ;data is loaded into the ULA video shift register during the refresh
      ;cycles of the 8 NOP opcodes when the I and R registers
      ;sequentially address 8 bytes of hires data in the 384 byte HFILE
      ;NOTE: in this special case of short (8 byte) video lines the delay
      ;opcodes (E3 and 40) have bit 6 high to suppress the video display
      ;at the start and end of each horizontal line

      E3 E3 E3 E3;Delay 76T states
      LD R,A     ;Now load R register
LBYTE 00 00 00 00;8 bytes of 8 pixels
      00 00 00 00;
      40 40 40 40;Delay 20T states
      40         ;Delay 4T
      JP (IX)    ;Return to HR

START ;Makes room above RAMTOP and starts the hires routine
      ;----------------------------------------------------
      LD IX,HR    ;This is the start of the new video routine
      LD BC,180   ;384 bytes are required for a 64X48 display
      CALL EC5    ;is there enough room to lower ramtop?
      LD HL,(4004);get the old RAMTOP (1K/2K)
      CCF         ;calculate the new RAMTOP value by
      SBC HL,BC   ;Subtracting the HFILE length

STACK ;used by START and STOP to change RAMTOP without NEW

      OUT FD,A    ;Turn off the NMI generator during STACK move
      LD (4004),HL;Save RAMTOP value in the sytem variable
      DEC HL      ;point to the first byte below RAMTOP
      LD (HL),3E  ;and mark it with 3E
      DEC HL
      LD SP,HL    ;Load the STACK POINTER
      DEC HL
      DEC HL
      LD (4002),HL;Load the ERROR STACK POINTER
      OUT FE,A    ;Turn on NMI
      JP 676      ;resume BASIC program execution at NEXT LINE


HR    ;PART 1 calls LBUF 48 times, displaying 64x48 pixels, calculates blank
      ;lines, saves pointer to PART 2 in IX,and returns to application code
      ;PART 2 calls VSYNC etc, checks the BREAK key, calculates blank lines,
      ;saves pointer to PART 1 in IX and returns to application code.

      LD B,04    ;load delay
HR0   DJNZ HR0   ;delay 56T states to synchronize with HSYNC pulses.
      LD HL,(4004);RAMTOP points to the first HFILE byte
      LD B,30    ;48 horizontal lines
      LD IX,HR1  ;save the return vector in IX (for JP (IX) at end of LBUF)
      JR HR2     ;skip HR1 first time through the loop
HR1   LD DE,08   ;this value for 8 bytes or 64 pixels per line is
      ADD HL,DE  ;added to HL to point to the start of the next HLINE
      DEC B      ;repeat 48 times
      JP Z HR3   ;if this is the last line JP to HR3
HR2   LD A,H     ;the address in HL is then transferred to
      LD I,A     ;I register
      LD A,L     ;and during LBUF to the R register
      JP C084    ;jump to LBUF (4084 + 8000) to start the video
HR3   LD IX,HR4  ;save the video vector so that NMI returns to PART 2
      JR HR5     ;now get blank lines and return to application code

HR4   ;PART 2

      CALL 220   ;first PUSH registers then jump to VSYNC, etc
      CALL F46   ;test the BREAK key
      JR NC STOP ;and exit HR if key is down
      LD IX,HR   ;save the video vector so that NMI returns to PART 1
HR5   LD A,(4028);33 or 19 blank lines in system variable MARGIN
      ADD A,47   ;71 more blank lines for fast application code execution
      JP 29E     ;save blank lines, start NMI, POP registers and RETURN
STOP             ;EXIT hires video to restore RAMTOP and SINCLAIR video
      LD A,1E    ;SINCLAIR ROM pattern table MSB base address (1E00)
      LD I,A     ;pointer to I register
      LD HL,(4004);load the current RAMTOP
      LD DE,180  ;HFILE length
      ADD HL,DE  ;is added to the current RAMTOP
      LD IX,0281 ;SINCLAIR video routine
      JR STACK   ;exit HR via STACK to change RAMTOP


     ;------------------END OF LISTING----------------
</pre>
<a name="15"></a>
<h3>15. PSEUDO HIRES CORE ROUTINES</h3>
<p>Pseudo hires software uses CHR$ code + register I to address 1 of 64 pattern 
  bytes in the ROM. The CHR$ codes are limited 0 to 63 and their inverse (128 
  to 191) and the value of I is choses to point to a block of pattern bytes in 
  ROM which has the greatest randomness and least duplication of values. This 
  method is called "pseudo" hires because fewer than 50% of the 256 
  patterns required for true hires are available for display. This results in 
  incomplete or missing pixel patterns but for many application (games etc) this 
  is not a problem. The advantage of this method is the fact that it runs on systems 
  the standard 16K RAMPACK and is emulated by Xtender.<br>
  It has a characteristic 6336 byte DFILE consisting of 192 RET opcodes spaced 
  at 33 byte intervals.</p>
<h4>ROCK CRUSH by Steve McDonald</h4>
<p>In progress</p>
<h4>3DHIRES author unknown</h4>
<p>In this example core routine the expanded hires "DFILE" starts at 
  6700 hex</p>
<pre>START   LD A,04   ; select an "interesting" pattern table
        LD I,A    ; load into ROM pattern table pointer
        LD IX,42C4; load pseudo hires vector
        RET

42C4    LD HL,E6DF; HL is used as the hires "DFILE" pointer
        LD DE,0021; 32 CHR$ + RET = 33 bytes per line
        DI        ; INT not used
        LD C,FE   ; IO address to reset the ULA row counter
        LD B,16   ; delay
42CF    DJNZ 42CF ; delay
        LD B,C0   ; 192 lines of 33 bytes
42D3    IN A,(C)  ; apply reset to row counter
        OUT FF,A  ; release reset from row counter
        ADD HL,DE ; next "DFILE" line (E700,E721, etc)
        CALL 42EC ; "execute" the "DFILE" via JP (HL) at 42EC
        DEC B     ; decrement line counter
        JP NZ 42D3; last line? repeat 192 times.
        CALL 0292 ; restore main registers, return to application
        CALL 0220 ; extra register PUSH then VSYNC
        LD IX,42C4; hires routine vector
        JP 02A4   ; restore main registers, return to application
        JP (HL)   ; jump to the hires "DFILE" echo above 32K
</pre>
<h4>XTRICATOR by Software Farm</h4>
<p>This unusual pseudo hires core routine intercepts the video by setting INT 
  mode 2 in which the interrupting device supplies part of the INT vector address. 
  Since the idle data bus is FF and the I register is set to 40, the INT vector 
  is 4000 when the A6 line interupts at the end of the horizontal line.</p>
<pre>4083    LD HL,40A5 ;return vector
4086    PUSH HL    ;save vector
4087    LD HL,E500 ;hires file
408A    PUSH HL    ;save vector
408B    LD B,07    ;delay
408D    DJNZ 408D  ;delay
408F    LD A,1E    ;Sinclair ROM patterns
4091    LD I,A     ;load pattern table pointer
4093    LD DE,C201 ;D = 194 lines
4096    DEC E      ;set Z FLAG
4097    JP Z 409A  ;delay
409A    POP HL     ;HL = E500
409B    DEC D      ;decrement the line counter
409C    RET Z      ;after last line only : return to 40A5
409D    SET 0,E    ;E = 01
409F    JP 40A2    ;delay
40A2    LD A,00    ;delay
40A4    JP (HL)    ;jump to 6500 above 32K

40A5    LD A,04    ;"special" ROM pattern
40A7    LD I,A     ;load pattern table pointer
40A9    RET        ;return to xxxx

40AA    LD A,40    ;INT mode 2 MSB address
40AC    LD I,A     ;load the INT mode 2 vector
40AE    IM2        ;start INT mode 2
40B0    RET

40B1    LD A,1E    ;Sinclair ROM patterns
40B3    LD I,A     ;load pattern table pointer
40B5    IM1        ;restore INT mode 1
40B7    RET

40B8    LD HL,6500 ;load a call instruction
40BB    LD B,C1    ;the start of HFILE (E500)
408D    LD (HL),CD ;CALL 4096
408F    INC HL
40C0    LD (HL),96
40C2    INC HL
40C3    LD (HL),40
40C5    INC HL
40C6    LD A,20     ;generate a 6144 spaces starting 
40C8    LD (HL),00  ;at 6503
40CA    INC HL
40CB    DEC A
40CC    JR NZ 40C8
40CE    DJNZ 40C6 
40D0    RET
</pre>
<hr><p><a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm#top"><img src="./ZX81 VIDEO DISPLAY SYSTEM_files/up.gif" width="20" heigth="11" border="0" alt="top"></a> 
<a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/wilfvid.htm#top">top</a> | <a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/index.htm"><img src="./ZX81 VIDEO DISPLAY SYSTEM_files/left.gif" alt="home" border="0"></a>
<a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/index.htm">home</a></p><a href="https://web.archive.org/web/20070830180756/http://home.germany.net/nils.eilers/zx81/index.htm">







<!--
     FILE ARCHIVED ON 18:07:56 Aug 30, 2007 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 10:25:14 Mar 26, 2017.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
</a></body></html>